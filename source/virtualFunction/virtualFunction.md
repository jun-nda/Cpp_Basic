### 虚函数

###### 一、基类指针可以指向派生类对象

因为指针的定义是由首地址和长度决定的，指针的值决定首地址，类型决定长度。基类指针保证对象首地址，并且保证只访问Base的部分。

![image-20250211143835281](C:\Users\yujunda\AppData\Roaming\Typora\typora-user-images\image-20250211143835281.png)图为内存布局。

反过来，如果使用派生类指针指向基类，则编译器就会告知错误，因为派生类指针此时一定会越界。

###### 二、虚函数是动态多态，函数重载是静态多态

子类可以重写父类函数，但这属于静态（编译期）多态，使用基类指针指向派生类对象，调用同名函数执行的还是基类函数。所以只有虚函数才能实现运行时多态。运行时多态的作用最明显体现在存在外部IO的情况，无法在编译期确定对象的类型。至于运行时多态是怎么来的，这是面向对象的三大原则，也就是各种语言根据面向对象的原则，来通过不同的方法来实现的语言机制。

###### 三、虚函数实现原理

我们可以通过对象的虚指针在运行时查询类的虚函数表。

1. 对象首地址转为指向虚表指针类型，由于虚表是一个指针数组func*类型，所以虚指针的类型为func**。
2. 然后解一次引用＋一个数组下标，或两次数组下标皆可，拿到函数地址，最后执行函数。
3. 虚函数表是类公用的，指向虚函数的指针是每个对象都有一个的，并且同类型相同。
4. 一个虚指针只占8字节（64位系统），无论多少个虚函数我都只需要一个虚指针。
5. 

![image-20250211182547210](C:\Users\yujunda\AppData\Roaming\Typora\typora-user-images\image-20250211182547210.png)

四、为什么必须指针或引用才能多态

这个就涉及编译器本身的问题了。不好解释。